# 装饰器

## 基础

1. 定义：就是一个函数或方法，可以注入到类、方法、属性、参数、对象上，扩展其功能。

**tips：高阶组件本质上也采用了装饰器的思想。**

2. 解决了什么问题？

**装饰器就是在解决不修改原来类、方法、属性、参数的情况下添加额外功能。**

在 nestJs 中装饰器可以解决依赖注入的问题，而依赖注入是 Java 等后端语言拥有的非常优秀的编程思想，有了依赖注入，能大大降低项目的耦合性，提升项目的可扩展性。

**使用和创建分离是依赖注入的核心思想。**

3. 装饰器分类：

- 类装饰器
- 属性装饰器
- 方法装饰器
- 参数装饰器
- 元数据装饰器

4. 元数据装饰器：在定义类、方法或对象时，可以设置一些元数据，需要引入 reflect-metadata 第三方库，采用@Reflect.metadata 来实现。

5. 装饰器的写法

- 调用时不传递参数的装饰器
- 装饰器工厂(调用时可以传递参数的装饰器)

### 泛型工厂类装饰器

## 方法装饰器

### 方法拦截器的意义

1. 通过修改装饰器，可以实现任意的功能而不用修改源代码，且能最大程度的复用。

2. 在方法拦截器中拦截目标类的方法，可以增强或修改目标类的方法的功能，如：打印日志信息，修改方法参数进行功能扩展处理。

### 拦截器的前置、后置功能实现

1. 前置拦截

```ts
function methodDecorator(
  prototype: any,
  key: string,
  desc: PropertyDescriptor
) {
  // pre-intercept
  // do something...

  desc?.value();
}
```

2. 后置拦截

```ts
function methodDecorator(
  prototype: any,
  key: string,
  desc: PropertyDescriptor
) {
  const self = desc?.value;
  // post-intercept
  // do something...
  desc.value = (...args: any[]) => {};

  desc.value();
}
```

## 属性装饰器

1. 元数据：为了增强类、方法、属性的功能，附加一些数据。

2. 分类：

- 自定义的元数据
- 内置元数据

## 依赖注入 + 请求方法

## 构造器装饰器

## 要点

1. 熟练掌握装饰器对职业发展的意义：

- 提升前端架构思维和前端架构能力，装饰器底层蕴含「拦截器」思想在 Java Spring、NestJS、Python 各种后端语言中都有广泛应用。**拦截器展示的是一种架构思维，通过学习装饰器能扩大技术视野，是一名前端架构的必备技能。**
- 在 nestJS 一些新型的优秀 nodejs 框架中使用了大量的 TS 装饰器，如：@controller, @Service, @Get, @Post

2. 具有架构思维的前端开发人员在大中型项目中一定能写出扩展性更好的代码。
