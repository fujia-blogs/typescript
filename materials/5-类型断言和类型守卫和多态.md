# 类型断言、类型守卫和多态

## 类型断言

1，理解：有重叠关系的两种数据类型，把其中一种数据类型转换为另一种数据类型

2，重叠关系的场景：

- 类 A 和 B，且有继承关系，一般情况下，是把父类的对象变量断言成子类
- 类 A 和 B，没有有继承关系，需要满足：两个类中的任意一个类的所有的 public 实例属性（不包括静态属性）和 public 实例方法与另一个类的所有 public 实例属性和所有的 public 实例方法完全相同或是另外一个类的子集，则这两个类可以相互断言，否则这两个类就不能相互断言
- 类 A 和接口 B，且 A 实现了(implements)B，则 A 的实例可以断言成 B 接口类型，B 接口类型的变量也可以断言成 A
- 类 A 和接口 B，且 A 没有实现了(implements)B，断言规则与第二条一致
- 类 A 和 type B，且 A 类实现了 B 定义的数据类型，则可以相互断言
- 类 A 和 typeB，且 A 没有实现了 B，断言规则与第二条一致
- A 是一个函数上参数变量的联合类型，在函数内部可以断言成联合类型中的一种
- 多个类组成的联合类型，变量可以断言成联合类型中任意一种
- 任何数据类型都可以转换成 any 或 unknown 类型，**any 或 unknown 类型也可以转换成任何其它的数据类型**

3，类型断言存在的意义和应用场景：

- 对象中的 Symbol 数据类型取值问题
- 加法计算，巧用 as any

## 类型守卫

1，在语句的块级作用域(if 语句或条目运算符表达式)缩小变量的类型推断的行为

2，TS 条件语句中遇到下列条件关键字时，会在语句的块级作用域内缩小变量的类型，这种类型推断的行为称作类型守卫 (Type Guard)。类型守卫可以帮助我们在块级作用域中获得更为需要的精确变量类型，从而减少不必要的类型断言。

- 类型判断：`typeof`
- 属性或者方法判断：`in`
- 实例判断：`instanceof`
- 字面量相等判断：`==`, `===`, `!=`, `!==`

3，typeof 局限性？如何解决？

- 用来检查一个变量或对象的数据类型
- 检测范围：string, number, bigint, boolean, symbol, undefined, object, function

局限性：

- 检测变量并不完全准确

4，typeof 的替代方案：Object.prototype.toString.call()

- 替代方案无法获取自定义的类的实例变量或构造函数的对象变量的真正创建类型，可以使用 instanceof 来解决

### instanceof

1，语法：[对象变量] instanceof [类名或函数名]

2，主要作用：准确地判断一种自定义函数或类创建的对象变量的数据类型

3，返回 true 的条件：

- [对象变量].\_\_proto\_\_ = [类名或函数名].prototype
- [对象变量].\_\_proto\_\_.[...].\_\_proto\_\_ = [类名或函数名].prototype

## 多态

1，多态的定义

父类的实例可以接受任何一个子类的实例，从而使用父类的实例来调用子类中重写的方法且输出不同的结果

2，产生多态的条件

- 必须存在继承关系
- 必须有方法重写

3，多态的好处

> 开闭原则 - 对修改关闭，对扩展开放

- 便于项目的扩展

4，局限性

- 无法直接调用子类的独有方法，必须结合 instanceof 类型守卫来处理

## 抽象类

1，定义：不能被实例化的类就是一个抽象类

2，什么定义一个抽象类？

简单来说，一个类被实例化后并没有意义就可以被定义为抽象类

3，抽象类的特点：

- 可以包含方法体的方法
- 可以包含实现了具体功能的方法
- 可以包含构造器
- 不能直接实例化，只能通过子类来实例化

4，抽象类的优势：

- 提供统一名称的抽象方法，提高代码的可维护性
- 阻止实例化一无意义的类

## 自定义守卫

1，示例：

```ts
function func(name: any): name is string {
  return typeof name === 'string';
}
```

理解：返回布尔值的条件表达式赋予类型守卫的能力，当函数返回 true 时，形参被确定为 string 类型

2，自定义守卫的意义：编码展示器具体的意义
