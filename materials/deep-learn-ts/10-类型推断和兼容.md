# 类型推断和兼容

1. TypeScript 能根据一些简单的规则推断（检查）变量的类型

2. 小心使用参数，如果类型不能被赋值推断出来，类型也将不会流入函数参数中。

3. 小心使用返回值，尽管 TypeScript 一般情况下能推断函数的返回值，但是它可能并不是你想要的。

4. noImplicitAny，选项 noImplicitAny 用来告诉编译器，当无法推断一个变量时发出一个错误(或者只能推断为一个隐式的 any 类型)你可以：

- 通过显式添加 :any 的类型注解，来让它成为一个 any 类型
- 通过一些更正确的类型注解来帮助 TypeScript 推断类型

## 兼容性

1. 类型兼容性用于确定一个类型是否能赋值给其它类型。

### 安全性

1. TypeScript 类型系统设计比较方便，它允许你有一些不正确的行为。例如：任何类型都能被赋值给 any，这意味着告诉编译器你可以做任何你想做的事情

### 结构化

1. TypeScript 对象是一种结构类型，这意味着只要结构匹配，名称也就无关紧要了

### 变体

1. 对类型兼容性来说，变体是一个利用理解和重要的概念。

对一个简单类型 Base 和 Child 来说，如果 Child 是 Base 的子类，Child 的实例能被赋值给 Base 类型的变量。

> 这是多态性

在由 Base 和 child 组合的复杂类型的类型兼容性中，它取决于相同场景下的 Base 和 child 的变体：

- 协变(covariant)：只在同一个方向
- 逆变(contravariant)：只在相反方向
- 双向协变(bivariant)：包括同一个方向和不同方向
- 不变(invariant)：如果类型不完全相同，它们是不兼容的。

**tips：对于存在完全可变数据的健全的类型系统（如 JavaScript），Invariant 是一个唯一的有效可选属性，但是如我们所讨论的，便利性迫使我们作出一些不是很安全的选择**

## 函数

1. 返回类型，协变（Covariant）：返回类型必须包含足够的数据

### 函数参数类型

1. 一个双向协变(bivariant)的例子，旨在支持常见的事件处理方案。

### 枚举

1. 枚举与数字类型相互兼容

2. **不同枚举的枚举变量，被认为是不兼容的。**

### 类

1. 仅仅只有实例成员和方法会相比较，构造函数和静态成员不会被检查。

2. 私有的和受保护的成员必须来自于相同的类。

### 泛型

1. TypeScript 类型系统基于变量的结构，仅当类型参数在被一个成员使用时，才会影响兼容性
