# TypeScript Tips

## 名义化类型

1. ts 的类型系统是结构化的，**这也是其主要优点之一。**

### 使用字面量

1. 使用泛型和字面量类型

优点：

- 不需要断言

缺点：

- 如上结构 {type,value} 可能不那么尽如人意，而且需要服务器序列化支持。

### 使用枚举

1. typescript 中枚举提供一定程度的名义化类型，如果两个枚举的命名不相同，则它们类型不相等，可以利用这个事实来为结构上兼容的类型，提供名义化类型。

解决办法包括：

- 创建一个只有名字的枚举
- 利用这个枚举与实际结构体创建一个交叉类型(&)

2. 使用一个 _ 映射到空字符串的成员，即 { _ = '' }。这可以**强制 TypeScript 推断出这是一个基于字符串的枚举，而不是一个数字类型的枚举。这是很重要的，因为 TypeScript 会把一个空的枚举类型（{}）推断为一个数字类型的枚举**，在 TypeScript 3.6.2 版本及其以上时，数字类型的枚举与 string 的交叉类型是 never。

### 使用接口

1. number 类型与 enum 类型在类型上是兼容的

2. 可以使用接口打破这种类型的兼容性。TypeScript 编译团队仍然在使用这种方法，因此它值得一提。使用 \_ 前缀和 Brand 后缀是一种我强烈推荐的惯例方法。

解决办法：

- 在类型上添加一个不用的属性，**用来打破类型兼容性**
- 在新建或向下转换类型的时候使用断言。

## 状态函数

1. 其他编程语言有一个共同特征，它们使用 static 关键字来增加函数变量的生命周期（不是范围），使其超出函数的调用范围，如 C 语言中的实现

2. 由于 JavaScript（TypeScript）并没有静态函数的功能，可以使用一个包裹本地变量的抽象变量，如使用 class。

## bind 是有害的

1. 类成员

另一个常见用途是在传递类函数时使用 bind 来确保 this 的正确值，不要这么做

**你想传递一个类成员的函数，使用箭头函数**

## 柯里化

1. **仅仅需要使用一系列箭头函数。**

## 泛型的实例化类型

1. 你有一个具有泛型参数的类型，如一个类 Foo，你想为一个特定的类型创建单独的版本，可以通过将它拷贝到一个新变量里，并且用具体类型代替泛型的类型注解的方式来实现。

### 继承

1. 类型断言模式是不安全的，因为编译器相信你在做正确的事情。

## 对象字面量的惰性初始化

1. 最好的解决方案是在为变量赋值时，添加属性及其对应的值。
