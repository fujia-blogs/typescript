# TypeScript Tips

## 名义化类型

1. ts 的类型系统是结构化的，**这也是其主要优点之一。**

### 使用字面量

1. 使用泛型和字面量类型

优点：

- 不需要断言

缺点：

- 如上结构 {type,value} 可能不那么尽如人意，而且需要服务器序列化支持。

### 使用枚举

1. typescript 中枚举提供一定程度的名义化类型，如果两个枚举的命名不相同，则它们类型不相等，可以利用这个事实来为结构上兼容的类型，提供名义化类型。

解决办法包括：

- 创建一个只有名字的枚举
- 利用这个枚举与实际结构体创建一个交叉类型(&)

2. 使用一个 _ 映射到空字符串的成员，即 { _ = '' }。这可以**强制 TypeScript 推断出这是一个基于字符串的枚举，而不是一个数字类型的枚举。这是很重要的，因为 TypeScript 会把一个空的枚举类型（{}）推断为一个数字类型的枚举**，在 TypeScript 3.6.2 版本及其以上时，数字类型的枚举与 string 的交叉类型是 never。

### 使用接口

1. number 类型与 enum 类型在类型上是兼容的

2. 可以使用接口打破这种类型的兼容性。TypeScript 编译团队仍然在使用这种方法，因此它值得一提。使用 \_ 前缀和 Brand 后缀是一种我强烈推荐的惯例方法。

解决办法：

- 在类型上添加一个不用的属性，**用来打破类型兼容性**
- 在新建或向下转换类型的时候使用断言。

## 状态函数

1. 其他编程语言有一个共同特征，它们使用 static 关键字来增加函数变量的生命周期（不是范围），使其超出函数的调用范围，如 C 语言中的实现

2. 由于 JavaScript（TypeScript）并没有静态函数的功能，可以使用一个包裹本地变量的抽象变量，如使用 class。

## bind 是有害的

1. 类成员

另一个常见用途是在传递类函数时使用 bind 来确保 this 的正确值，不要这么做

**你想传递一个类成员的函数，使用箭头函数**

## 柯里化

1. **仅仅需要使用一系列箭头函数。**

## 泛型的实例化类型

1. 你有一个具有泛型参数的类型，如一个类 Foo，你想为一个特定的类型创建单独的版本，可以通过将它拷贝到一个新变量里，并且用具体类型代替泛型的类型注解的方式来实现。

### 继承

1. 类型断言模式是不安全的，因为编译器相信你在做正确的事情。

## 对象字面量的惰性初始化

1. 最好的解决方案是在为变量赋值时，添加属性及其对应的值。

2. 创建 interface，好处是：

- 方便撰写类型文档
- typescript 会参与类型检查，确保类型安全。

## 类是有用的

1. 使用类，可以在一定程度上更好的组织代码。

- 这不仅仅有利于开发者，在创建基于类的更出色的可视化工具中，它更常见。且有利于项目的理解和维护。

## export default 被认为是有害的

1. 存在一些可维护性的问题

- 如果你在 foo.ts 里重构 Foo，在 bar.ts 文件中，它将不会被重新命名
- 如果你最终需要从 foo.ts 文件中导出更多有用的信息（在你的很多文件中都存在这种情景），那么你必须兼顾导入语法

**由于这些原因，建议在导入时使用简单的 export 与解构的形式**

2. 默认导出的可发现性非常差，你不能智能的辨别一个模块它是否有默认导出。

3. 自动完成

不管你是否了解导出，你都可以在 import { /_ here _/ } from './foo' 的 here 位置，来了解导出模块的信息。

4. CommonJS 互用

对于必须使用 const { default } = require('module/foo') 而不是 const { Foo } = require('module/foo') 的 CommonJS 的用户来说，这会是一个糟糕的体验。当你导入一个模块时，你很可能想重命名 default 作为导入的名字。

5. 防止拼写错误

当你在开发时使用 import Foo from './foo' 时，并不会得到有关于拼写的任何错误

6. 再次导出

再次导出是没必要的，但是在 npm 包的根文件 index 却是很常见。如：

```ts
import Foo from './foo';

export { Foo };

export * from './foo';
```

7. 动态导入

在动态 import 中，默认导出会以 default 的名字暴露自己。

## 减少 setter 属性的使用

1. 倾向于使用更精确的 set/get 函数(如：setBar, getBar)，减少使用 setter/getter

## 谨慎使用--outFile

1. 由于以下几点原因，你应该谨慎使用 --outFile 选项：

- 运行时的错误；
- 快速编译；
- 全局作用域；
- 难以分析；
- 难以扩展；
- \_references；
- 代码重用；
- 多目标；
- 单独编译；

2. 全局作用域

可以使用命名空间，但是它仍然在 window 上，命名空间仅仅是一个临时的解决方式。///\<reference 也不例外，它会引入一个难以维护的全局上下文。

如果你的公司有多个独立工作的团队，当有人决定尝试集成两个程序编写 app 时，则很可能存在命名冲突。

3. 难以分析

4. 难以扩展

实际上这是运行时的随机错误+编译时间时间慢+难以理解的代码的结果。

5. --out 做的是一些构建工具的工作，这些构建工具也可以受益于外部模块所提供的依赖，因此如果你愿意，我们推荐你使用外部模块，让构建工具创建单文件的 .js。
