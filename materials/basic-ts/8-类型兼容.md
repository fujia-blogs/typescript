# 类型兼容

1. TypeScript 中有静态类型检测，所以不能像 JavaScript 中那样，赋给变量任意类型的值。

2. 在 TS 中能不能把一个类型赋值给其它类型是由类型兼容性决定的。

## 特殊类型

1. any

any 类型可以赋值给除了 never 之外的任意其他类型，反过来其他类型也可
以赋值给 any

2. never

never 的特性是可以赋值给任何其他类型，但反过来不能被其他任何类型（包括 any 在内）赋值（即 never 是 bottom type）。

3. unknown

unknown 的特性和 never 的特性⼏乎反过来，即不能把 unknown 赋值给除了 any 之外任何其它类型，反过来其它类型都可以赋值给 unknown(即 unknown 时 top type)

4. void, null, undefined

void、null、undefined 这三⼤废材类型的兼容性也很特别，⽐如 void 类型仅可以赋值给 any 和 unknown 类型，反过来仅 any、never、undefined 可以赋值给 void

**推崇并使⽤的严格模式下，null、undefined 表现出与 void 类似的兼容性，即不能赋值给除 any 和 unknown 之外的其他类型，反过来其他类型（除了 any 和 never 之外）都不可以赋值给 null 或 undefined**

5. enum

enum 枚举类型，其中数字枚举和数字类型相互兼容。

## 类型兼容性

typescript 中类型的兼容性都是**基于结构化子类型**的一般原则进行判定的。

### 子类型

1. 从⼦类型的⻆度来看，所有的⼦类型与它的⽗类型都兼容。

2. 由子类型组成的联合类型也可以兼容它们父类型组成的联合类型。

### 结构类型

1. 类型兼容的另一个准则是**结构类型**，即如果两个类型的结构一致，则他们相互兼容的。

2. 两个接⼝类型或者类，如果其中⼀个类型不仅拥有另外⼀个类型全部的属性和⽅法，还包含其他的属性和⽅法（如同继承⾃另外⼀个类型的⼦类⼀样），那么前者是可以兼容后者的。

**⼀个需要特别注意的特性：虽然包含多余属性 id 的变量 2 可以赋值给变量 1，但是如果我们直接将⼀个与变量 2 完全⼀样结构的对象字⾯量赋值给变量 1，则会提示⼀个 ts(2322) 类型不兼容的错误，这就是对象字⾯的 freshness 特性**

```ts
interface I1 {
  name: string;
}
interface I2 {
  id: number;
  name: string;
}
class C2 {
  id = 1;
  name = '1';
}

let i1: I1;
let i2: I2 = {
  id: 1,
  name: 'fujia',
};
let i3 = {
  id: 2,
  name: 'name',
};
let instanceC2: C2;

// i1 = {
//   id: 2,
//   name: 'jia'
// }

i1 = i2;
i1 = i3;
// i1 = instanceC2;
```

⼀个对象字⾯量没有被变量接收时，它将处于⼀种 freshness 新鲜的状态。这时 TypeScript 会对对象字⾯量的赋值操作进⾏严格的类型检测，**只有⽬标变量的类型与对象字⾯量的类型完全⼀致时，对象字⾯量才可以赋值给⽬标变量，否则会提示类型错误。**

**也可以通过使⽤变量接收对象字⾯量或使⽤类型断⾔解除 freshness。**

3. 类兼容性特性

实际上，在判断两个类是否兼容时，我们可以完全忽略其构造函数及
静态属性和⽅法是否兼容，只需要⽐较类实例的属性和⽅法是否兼容即可。如果两个类包含私有、受保护的属性和⽅法，则仅当这些属性和⽅法源⾃同⼀个类，它们才兼容。

### 可继承和可实现

1. 类型兼容性还决定了接口类型和类是否可以通过 extends 继承另外一个接口类型或者类，以及类是否可以通过 implements 实现接口。

### 泛型

1. 泛型类型、泛型类的兼容性实际指的是将它们实例化为一个确切类型后的兼容性。

### 变型

1. 函数类型兼容性的理论知识：变型。

2. TS 中的变型指的是根据类型之间的子类型关系推断基于它们构造的更复杂类型之间的子类型关系。

在描述类型和基于类型构造的复杂类型之间的关系时，我们可以使⽤数学中函数的表达⽅式。⽐如 Dog 类型，我们可以**使⽤ F(Dog) 表示构造的复杂类型**；**F(Animal) 表示基于 Animal 构造的复杂类型**。

这⾥的变型描述的就是基于 Dog 和 Animal 之间的⼦类型关系，从⽽得出 F(Dog) 和 F(Animal) 之间的⼦类型关系的⼀般性质。⽽这个性质体现为⼦类型关系可能会被**保持、反转、忽略**，因此它可以被划分为**协变、逆变、双向协变和不变**这 4 个专业术语。

### 协变

协变就是说如果 Dog 是 Animal 的子类型，则 F(Dog)是 F(Animal)的子类型，这意味着在构造的复杂类型中保持了一致的子类型关系。

1. 实际上接口类型的属性、数组类型、函数返回值的类型都是协变的。

即接⼝类型 { type: Dog } 是 { type: Animal } 的⼦类型，数组类型
Dog[] 是 Animal[] 的⼦类型，函数类型 () => Dog 也是 () => Animal 的⼦类型。

### 逆变

逆变是说如果 Dog 是 Animal 的子类型，则 F(Dog)是 F(Animal)的父类型，这与协变正好反过来。

1. 实际场景下，ts 的严格模式下，函数参数类型是逆变的。

2. **可以从安全性的⻆度理解函数参数是逆变的设定。**

如果函数参数类型是协变⽽不是逆变，那么意味着函数类型 (param: Dog) => void 和 (param: Animal) => void 是兼容的，这与 Dog 和 Animal 的兼容⼀致，所以我们可以⽤ (param: Dog) => void 代替 (param: Animal) => void 遍历 Animal[] 类型数组。

但是，这样是不安全的，因为它不能确保 Animal[] 数组中的成员都是 Dog（可能混⼊ Animal 类型的其他⼦类型，⽐如 Cat），这就会导致 (param: Dog) => void 类型的函数可能接收到 Cat 类型的⼊参。

### 双向协变

1. 双向协变即说如果 Dog 是 Animal 的子类型，则 F(Dog)是 F(Animal)的子类型，也是父类型，既是协变也是逆变。

2. 实际场景中，在 TypeScript **⾮严格模式**下，函数参数类型就是双向协变的。

**函数只有在参数是逆变的情况下才安全，** 且建议开启严格模式，**所以双向协变并不是一个安全或者有用的特性，不⼤可能遇到这样的实际场景。**

### 不变

1. 即只要是不完全一样的类型，它们一定是不兼容的。也就是说即便 Dog 是 Animal 的⼦类型，如果 F(Dog) 不是 F(Animal) 的⼦类型，那么 F(Animal) 也不是 F(Dog) 的⼦类型。

2. 实际场景下，出于类型安全层⾯的考虑，在特定情况下我们可能希望数组是不变的（实际上是协变）。

3. **对于可变的数组而言，不变似乎是更安全、合理的设定。不过，在 TS 中可变、不变的数组都是协变的，这是需要的一个陷阱。**

### 函数类型兼容性

函数类型的兼容性、⼦类型关系有着更复杂的考量，它还需要结合参数和返回值的类型进⾏确定。

1. 返回值

返回值类型是协变的，所以在参数类型兼容的情况下，函数的⼦类型关系与返回值⼦类型
关系⼀致。也就是说返回值类型兼容，则函数兼容。

2. 参数类型

参数类型是逆变的，所以在参数个数相同、返回值类型兼容的情况下，函数⼦类型关系与参
数⼦类型关系是反过来的（逆变）。

3. 参数个数

在索引位置相同的参数和返回值类型兼容的前提下，函数兼容性取决于参数个数，参数个数少的兼容个数多

可以从安全性⻆度理解（是参数少的函数赋值给参数多的函数安全，还是参数多的函数赋值给参数少的函数安全）

4. 可选和剩余参数

可选参数可以兼容剩余参数、不可选参数

**必选参数和剩余参数是相互兼容的。** 把不可选参数 requiredParams 赋值给剩余参数 restParams 其实是不安全的（但是符合类型检测），需要从⽅便性上理解这个设定。

正是基于这个设定，我们才可以将剩余参数类型函数定义为其他所有参数类型函数的⽗类型，并⽤来约束其他类型函数的类型范围，⽐如说在泛型中约束函数类型⼊参的范围。

## 要点

1. 从安全性⻆度解释⼀下为什么参数个数少兼容个数多？不可选参数和剩余参数互相兼容
   吗？

2. 不可选参数和剩余参数是互相兼容的；剩余参数函数可以兼容任意个数参数函
   数，这是安全的；不可选参数是剩余参数函数((...args: any[]) => any）⼦类型，是不安全但是便捷的，所以不可选兼容剩余

3. **赋值是编程中一个非常常见的操作，** 因为类型兼容性决定了赋值操作是否可以通过类型检测。
