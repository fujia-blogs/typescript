# FAQs

## 类型系统的行为

1. TypeScript 使用结构化类型，这个系统并不同于你可能使用过的一些其他流行语言（如：Java、C# 等）的类型系统。

2. **结构化类型系统别后的思想是如果他们的成员类型是兼容的，则它们是兼容的。**

3. 这对于习惯于使用名义类型语言的程序员来说，会产生一些令人惊讶的结果。在这个 FAQs 中的许多问题，都可以追溯到结构化类型及其含义。一旦你掌握了它的基础知识，就很容易理解了。

### 什么是类型删除？

1. TypeScript 移除了类型断言、接口、类型别名和一些其他编译期间的类型结构。

2. 对于习惯使用反射或其他元数据系统的程序员来说，缺少的运行时类型信息可能是令人惊讶的。FAQs 中的许多问题都可以归结为「因为类型被删除」。

### 为什么函数参数是双向协变？

1. 是由于类型系统中缺乏显示协变/逆变注解而导致的不健全。由于它们的缺失，当被问及到 (x: Dog) => void 是否能够赋值给 (x: Animal) => void 时，TypeScript 必须更加的宽容处理。

2. 总的来说，在 TypeScript 的类型系统里，一个接收更多特定类型参数的函数是否能够赋值给一个较少特定类型参数的函数的问题，它的答案有一个先决条件 - 有更多特定类型的数组能够赋值到一个较少特定类型的数组吗？在大多数情况下，如果后者不是这情情况，则认为是不被允许的。所以我们必须对函数参数类型的特定情况进行正确的权衡。

### 为什么所有的类型，都能赋值给一个空的接口？

1. 没有成员的类型，能够被任何类型替代

2. 一般来说，你永远不应该声明没有属性的 interface。

### 我可以用名义上的类型别名吗？

1. 类型别名只是一个简单的别名，它们无法区分自己所表示的类型。

### 如何防止两种类型在结构上兼容？

1. **如果你真的希望两种类型不兼容，一种方式添加一个「brand」成员。**

### 如果对象实现了某个接口，我怎么在运行时检查？

## 函数

## 类

### 为什么这些空类的行为很奇怪？

1. **一般来说，你永远不应该声明一个没有属性的类。即使对于子类也是如此**

### 什么是名义上的类？

1. 在 TypeScript 中，类进行结构上的比较，有一个例外是对于 private 与 protected 的成员。当一个成员是 private 或者 protected 时，它们必须来自同一个声明，才能被视为与另一个 private 或者 protected 的成员相同。

### 为什么在我的实例方法中，this 成了一个「孤儿」？

1. 在 JavaScript 中，this 值由以下确定：

- 函数是调用.bind 的结果吗？如果是，this 由传递给 bind 的第一个参数确定。

- 函数是通过属性表达式 expr.method()直接调用吗？如果是，this 指向 expr
- 否则，this 是 undefined（在严格模式中），或者是 window （非严格模式中）。

### 当 Bar 是一个 class 时，Bar 和 typeof Bar 有什么区别？

1. JavaScript 中类仅仅是个函数，这点很重要。

2. 当我们定义一个类时，实际上，定义了两个不同的类型：

- 由类的名字推导而来。这个是类实例的类型，它定义了类的实例具有的属性和方法，它是一个通过调用类的构造函数来返回的类型。
- 第二个类型是一个匿名的类型，它是构造函数具有的类型。它包含一个返回类实例的构造函数签名（可以使用 new 调用），同时，它也包含类中可能含有的 static 属性和方法。它也通常被称为「静态方面」，因为它包含那些静态成员（以及作为类的构造函数）。我们可以用 typeof 来引用此类型

**当在类型位置使用 typeof 操作符时，描述了表达式的类型。**

### 接口继承类，意味着什么？

1. 总的来说，这种模式是应当避免的，尤其是在 Foo 有私有成员时。

### 为什么不扩展 Error、Array、Map 内置函数？

1. 在 ES2015 中，返回一个对象的构造函数将 this 的值隐式替换为 super(...) 的任何调用者。这对于构造函数代码捕获 super(...) 的任何潜在返回值并将其替换为 this 是必要的。

## 泛型

### 通过接口 A\<T>，为什么 A\<string> 可赋值给 A\<number>？

1. typescript 使用了一种结构类型的系统。

2. 通常，不应该有未使用类型的参数，该类型会有无法预料的兼容性，同时在函数调用中也无法获取正确的泛型类型接口。

### 为什么不要在泛型函数中写 typeof T、new T, 或者 instanceof T？

## 类型守卫

### 为什么 x instanceof Foo 不能将 x 的类型缩小至 Foo？

1. 这取决于 x 是什么？如果 x 的类型不与 Foo 兼容，那么缩小 x 的类型就毫无意义，所以我们不会这么做。

## tsconfig.json 的行为

### 为什么把一个文件放入「exclude」选项中，它仍然会被编译器选中？

1. tsconfig.json 将会把一个文件夹转换为「项目」，如果不指定任何 exclude 或者 files，则包含在 tsconfig.json 中的所有文件夹中的所有文件都会被包含在编译中。

2. 模块解析：编译器将尝试去理解 ns 在模块语法中表示什么，即 import \* as ns from 'mod'。为了理解它，编译器需要定义一个模块，它可能是包含你自己代码的 .ts 文件，或者是导入的一个 .d.ts 文件。如果一个文件被找到，则无论它是否在 excludes 中，它都将会被编译。

3. 使用 tsc --listFiles 来列出在编译时包含了哪些文件，tsc --traceResolution 来看看它们为什么会被包含在编译中。

### 我怎么指定一个 include？

1. 无法在 tsconfig.json 的 include 选项外指定所需要包含的文件。你可以通过以下任意一种方式获得相同的结果：

- 使用 files 列表
- 在目录中添加 ///\<reference path=""> 指令。
