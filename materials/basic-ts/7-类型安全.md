# 类型安全

1. typescript 的基础认知：

类型元素：

- 原始类型；
- 字面量类型；
- 数组类型；
- 函数类型；
- 类类型；
- 接口类型；
- 类型别名；
- 联合与交叉类型；
- 枚举类型；
- 泛型

特性：

- 类型推断；
- 类型断言；
- 类型缩小；
- 类型放大。

## 类型守卫

1. JavaScript 作为⼀种动态语⾔，意味着其中的参数、值可以是多态（多种类型）。因此，我们需要区别对待每⼀种状态，以此确保对参数、值的操作合法。

2. 在 TS 中，受静态类型检测约束，在编码阶段必须使用类似的手段确保当前的数据类型支持相应的操作。

3. **类型守卫的作用在于触发类型缩小，实际上，还可以用来区分类型集合中的不同成员**

类型集合一般包括联合类型和枚举类型。

### 如何区分联合类型？

1. 常用的类型守卫包括：

- switch;
- 字面量恒等式；
- typeof；
- instanceof;
- in；
- 自定义类型守卫；

2. 使⽤ switch 类型守卫来处理联合类型中成员或者成员属性可枚举的场景，即字⾯量值的集合。

3. 字面量恒等式，switch 适⽤的场景往往也可以直接使⽤字⾯量恒等⽐较进⾏替换。

**建议：⼀般来说，如果可枚举的值和条件分⽀越多，那么使⽤ switch 就会让代码逻辑更简洁、更清晰；反之，则推荐使⽤字⾯量恒等进⾏判断。**

4. typeof，当联合类型的成员不可枚举，⽐如说是字符串、数字等原⼦类型组成的集合，这个时候就需要使⽤ typeof。

5. instanceof，联合类型的成员还可以是类。

6. in

当联合类型的成员包含接⼝类型（对象），并且接⼝之间的属性不同，需要使⽤ in 操作符来判断类型。

7. 自定义类型守卫

通过类型谓词 is，封装自定义类型守卫。

### 区别枚举类型

1. 枚举类型是命名常量的集合，需要使⽤类型守卫区分枚举类型的成员。

2. 枚举类型的特性：

- 枚举和其它任何枚举、类型都不可比较，除了数字枚举可以与数字类型⽐较之外；
- 数字枚举极其不稳定。

**最佳实践是，我们永远不要拿枚举和除了⾃身之外的任何枚举、类型进⾏⽐较。**

3. 如果要使用双重类型断言来绕过 ts 静态类型检测，**需要极其谨慎，而且还需要添加警示信息进行说明。**

### 失效的类型守卫

1. 失效的类型守卫指的是某些类型守卫应⽤在泛型函数中时不能缩⼩类型，即失效了。

## 问答

Q1：如何区分不同的接口对象类型？
