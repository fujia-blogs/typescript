# TS 类型

1. TypeScript 其实就是类型化的 JavaScript，不仅支持 JavaScript 的所有特性，还在 JavaScript 的基础上添加了**静态类型注解扩展。**

可以把 typescript 代码的编写看作是为 JavaScript 代码添加类型注解。

## 原始类型

1. 在 JavaScript 中，原始类型指的非对象且没有方法的数据类型，包括：string, number, bigint, boolean, undefined 和 symbol(**null 是一个伪原始类型，它在 JavaScript 中实际上是一个对象，且所有的结构化类型都是通过 null 原型链派生而来**)

2. 在 JavaScript 语⾔中，原始类型值是最底层的实现，对应到 TypeScript 中同样也是最底层的类型。

### 数字

1. 可以使⽤ number 类型表示 JavaScript 已经⽀持或者即将⽀持的数字类型：

- 十进制整数；
- 浮点数；
- 二进制数；
- 八进制数；
- 十六制数。

2. 使⽤较少的⼤整数，可以使⽤ bigint 类型来表示。

> BigInt - https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/BigInt

BigInt 是一种内置对象，提供了一种方法表示大于 2^53 - 1 的整数。BigInt 可以表示任意大的整数。

- 在一个整数字面量后面加 n 的方式定义一个 BigInt。

与 number 的区别：

- 不能用于 Math 对象中的方法；
- 不能和任何 Number 实例混合运算，两者必须转换成一种类型；
- BigInt 和 Number 不是严格相等的，但是宽松相等的;
- Number 和 BigInt 可以进行比较;
- BigInt 变量在转换成 Number 变量时可能会丢失精度。

**建议：仅在值可能大于 2^53 时使用 BigInt 类型，并且不在两种类型之间进行相互转换**

对任何 BigInt 值使用 JSON.stringify() 都会引发 TypeError，因为默认情况下 BigInt 值不会在 JSON 中序列化。

### Symbol

1. TypeScript 还包含 Number、String、Boolean、Symbol 等类型（注意区分⼤⼩写）,注意将它们和⼩写格式对应的 number、string、boolean、symbol 区别。

## 静态类型检测

1. 在编译时期，静态类型的编程语⾔即可准确地发现类型错误，这就是静态类型检测的优势。

2. TypeScript 的语言服务可以和 VS Code 完美集成，**在编写代码的同时，可以同步进行静态类型检测，极大地提升了开发体验和效率。**

## 数组和元组

1. TypeScript 中的数组和元组转译为 JavaScript 后都是数组。

2. Array 中的泛型推荐使用[]形式来定义，⼀⽅⾯可以避免与 JSX 的语法冲突，另⼀⽅⾯可以减少不少代码量。

3. **元组最重要的特性是可以限制元素的个数和类型，特别合适用来实现多值返回。**

4. 出于较好的扩展性、可读性和稳定性考虑，建议 **把不同类型的值通过键值对的形式塞到一个对象中，再返回这个对象。** 而不是使用没有限制的数组。

5. 数组类型的值只有显示添加了元组类型注解后（或者使⽤ as const，声明为只读元组），TypeScript 才会把它当作元组，否则推荐出来的类型就是普通的数组类型

## any

1. any 指的是⼀个任意类型，它是官⽅提供的⼀个选择性绕过静态类型检测的作弊⽅式。

2. 可以对被注解为 any 类型的变量进⾏任何操作，包括获取事实上并不存在的属性、⽅法，并且 TypeScript 还⽆法检测其属性是否存在、类型是否正确。

3. 可以把任何值赋值给 any 类型的变量，也可以把 any 类型的值赋值给任意类型，**never 除外**

4. **Any is Hell.**

5. 除⾮有充⾜的理由，否则应该尽量避免使⽤ any ，并且开启禁⽤隐式 any 的设置。

## unknown

1. unknown 是 TypeScript3.0 添加的类型，用来表示类型并不确定的变量。

2. **与 any 相比，unknown 在类型更安全。** 可以将任意类型的值赋值给 unknown，但 unknown 类型的值只能赋值给 unknown 或 any。

3. 使用 unknown 后，typescript 会对它做类型检测。但是，如果不缩小类型(Type Narrowing)，对 unknown 执行的任何操作都会提示`ts(2571)`错误，所有的类型缩小手段对 unknown 都有效。

## void，undefined，null

1. 依照官⽅的说法，它们实际上并没有太⼤的⽤处。

2. 在 strict 模式下，声明⼀个 void 类型的变量⼏乎没有任何实际⽤处，因为我们不能把 void 类型的变量值再赋值给除了 any 和 unkown 之外的任何类型变量。

3. undefined 的最⼤价值主要体现在接⼝类型上，它表示⼀个可缺省、未定义的属性。

4. 可以把 undefined 值或类型是 undefined 的变量赋值给 void 类型变量，反过来，类型是 void 但值是 undefined 的变量不能赋值给 undefined 类型。

- undefined 可以赋值给 void 类型，但 void 类型不能赋值给 undefined 类型。

5. null 的价值主要体现在接⼝制定上，它表明对象或属性可能是空值。

undefined 和 null 类型还具备警示意义，提醒开发者操作这两种类型的值要做容错处理。

需要通过类型守卫(Type Guard)在操作之前判断值的类型是否⽀持当前的操作。**不建议随意使⽤⾮空断⾔来排除值可能为 null 或 undefined 的情况，因为这样很不安全。**

**推荐使用：** 单问号，双问号(空值合并)来保障代码的安全性。

## never 表示永远不会发⽣值的类型。

1. 函数代码中是⼀个死循环，那么这个函数的返回值类型也是 never.

2. never 是所有类型的子类型，可以给所有类型赋值。除了 never ⾃身以外，其他类型（包括 any 在内的类型）都不能为 never 类型赋值。

3. 在恒为 false 的类型守卫条件判断下，变量的类型将缩⼩为 never（never 是所有其他类型的⼦类型，所以是类型缩⼩为 never，⽽不是变成 never）。因此，条件判断中的相关操作始终会报⽆法更正的错误（我们可以把这理解为⼀种基于静态类型检测的 Dead Code 检测机制）。

4. 基于 never 的特性，可以使⽤ never 实现⼀些有意思的功能。如可以把 never 作为接⼝类型下的属性类型，⽤来禁⽌写接⼝下特定的属性。

## 类型断言

1. 避免与 JSX 产出语法冲突，推荐使用 as 语法。

2. 类型断⾔的操作对象必须满⾜某些约束关系，否则我们将得到⼀个 ts(2352) 错误，即从类型“源类型”到类型“⽬标类型”的转换是错误的，因为**这两种类型不能充分重叠。**

3. any 和 unknown 这两个特殊类型属于万⾦油，因为它们既可以被断⾔成任何类型，反过来任何类型也都可以被断⾔成 any 或 unknown。

4. **还可以使用"字面量值+as const"**语法结构进行常量断言。

5. ⾮空断⾔，即在值（变量、属性）的后边添加 '!' 断⾔操作符，它可以⽤来排除值为 null、undefined 的情况，**注意：应该把它视作和 any 一样危险的选择。**

在复杂应⽤场景中，如果我们使⽤⾮空断⾔，就⽆法保证之前⼀定⾮空的值，⽽⼀旦保证被改变，错误只会在运⾏环境中抛出，⽽静态类型检测是发现不了这些错误的。

建议使用类型守卫来代替非空断言。

## 字面量类型

1. 在 TS 中，字面量不仅可以表示值，还可以表示类型，即字面量类型。

2. 3 种字面量类型：

- 字符串字面量类型；
- 数字字面量类型；
- 布尔字面量类型。

3. 字⾯量类型是集合类型的⼦类型，它是集合类型的⼀种更具体的表达。

4. 实际上，定义单个的字⾯量类型并没有太⼤的⽤处，它真正的应⽤场景是可以把多个字⾯量类型组合成⼀个联合类型，⽤来描述拥有明确成员的实⽤的集合。

使⽤字⾯量类型（组合的联合类型）可以将函数的参数限定为更具体的类型。这不仅提升了程序的可读性，还保证了函数的参数类型，可谓⼀举两得。

### Literal Widening

通过 let 或 var 定义的变量、函数的形参、对象的⾮只读属性，如果满⾜指定了初始值且未显式添加类型注解的条件，那么它们推断出来的类型就是指定的初始值字⾯量类型拓宽后的类型，这就是字⾯量类型拓宽。

1. 实际上，除了字面量类型拓宽之外，typescript 对某些特定类型值也有类似"Type Widening"（类型拓宽）的设计。

### Type Widening

1. null 和 undefined 的类型拓宽，通过 let、var 定义的变量如果满⾜未显式声明类型注解且被赋予了 null 或 undefined 值，则推断出这些变量的类型是 any。

**如果开启了 strictNullChecks=true，则不会发生类型拓宽。**

### Type Narrowing

1. 在 ts 中，可以通过某些操作将变量的类型由一个较为宽泛的集合缩小到相对较小、较明确的集合，即"Type Narrowing"

## 类型推断

在很多情况下，TypeScript 会根据上下⽂环境⾃动推断出变量的类型，⽆须我们再写明类型注解，这种基于赋值表达式推断类型的能力称之为“类型推断”

1. 在 TypeScript 中，类型标注声明是在变量之后（即类型后置），它不像 Java 语⾔⼀样，先声明变量的类型，再声明变量的名称。

2. **上下文推断**

在某些特定的情况下，可以通过变量所在的上下文环境推断变量的类型。
